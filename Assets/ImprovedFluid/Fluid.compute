//
// GLOBAL VARIABLES
//

int n, n2;
float dt;



//
// GLOBAL METHODS
//

/* Returns whether an element is legally within the bounds of the grid. */
bool IsInBounds(uint2 id) {
	return id.x >= 1 && id.y >= 1 && id.x <= (uint)n && id.y <= (uint)n;
}

/* Converts a 2d index into a 1d index. */
uint To1D(uint2 id) {
	return id.y*n2 + id.x;
}

/* Converts two indicies into a 1d index. */
uint To1D(int x, int y) {
	return y*n2 + x;
}



//
// SIMULATION METHODS
//

#pragma kernel AddSource

int as_n;
RWStructuredBuffer<float> as_x, as_s;
float as_dt;

[numthreads(32, 32, 1)]
void AddSource(uint2 id : SV_DispatchThreadID) {
	as_x[To1D(id)] += as_dt*as_s[To1D(id)];
}



#pragma kernel LinearSolve

int ls_n, ls_b;
RWStructuredBuffer<float> ls_x, ls_x0;
float ls_a, ls_c;

[numthreads(32, 32, 1)]
void LinearSolve (uint2 id : SV_DispatchThreadID) {
	if (IsInBounds(id)) {
		for (int k = 0; k < 20; k++) {
			ls_x[To1D(id)] = (ls_x0[To1D(id)] + ls_a*(
				ls_x[To1D(id-uint2(1, 0))] +
				ls_x[To1D(id+uint2(1, 0))] +
				ls_x[To1D(id-uint2(0, 1))] +
				ls_x[To1D(id+uint2(0, 1))])) / ls_c;
		}
	}
}



#pragma kernel ProjectStart

int ps_n;
RWStructuredBuffer<float> ps_u, ps_v, ps_p, ps_div;

[numthreads(32, 32, 1)]
void ProjectStart(uint2 id : SV_DispatchThreadID) {
	if (IsInBounds(id)) {
		ps_div[To1D(id)] = -0.5 * (
			ps_u[To1D(id + uint2(1, 0))] -
			ps_u[To1D(id - uint2(1, 0))] +
			ps_v[To1D(id + uint2(0, 1))] -
			ps_v[To1D(id - uint2(0, 1))]) / ps_n;

		ps_p[To1D(id)] = 0.0;
	}
}



#pragma kernel ProjectFinish

int pf_n;
RWStructuredBuffer<float> pf_u, pf_v, pf_p;

[numthreads(32, 32, 1)]
void ProjectFinish(uint2 id : SV_DispatchThreadID) {
	if (IsInBounds(id)) {
		pf_u[To1D(id)] -= 0.5 * pf_n * (pf_p[To1D(id + uint2(1, 0))] - pf_p[To1D(id - uint2(1, 0))]);
		pf_v[To1D(id)] -= 0.5 * pf_n * (pf_p[To1D(id + uint2(0, 1))] - pf_p[To1D(id - uint2(0, 1))]);
	}
}



#pragma kernel Advect

int ad_n, ad_b;
RWStructuredBuffer<float> ad_d, ad_d0, ad_u, ad_v;
float ad_dt;

[numthreads(32, 32, 1)]
void Advect(uint2 id : SV_DispatchThreadID) {
	int i, j, i0, j0, i1, j1;
	i = id.x;
	j = id.y;

	float x, y, s0, t0, s1, t1, dt0;

	dt0 = ad_dt * ad_n;

	if (IsInBounds(id)) {
		x = (float)i - dt0*ad_u[To1D(id)];
		y = (float)j - dt0*ad_v[To1D(id)];
		
		x = max(x, 0.5);
		x = min(x, ad_n+0.5);
		i0 = (int)x;
		i1 = i0 + 1;
				
		y = max(y, 0.5);
		y = min(y, ad_n+0.5);
		j0 = (int)y;
		j1 = j0 + 1;

		s1 = x - (float)i0;
		s0 = 1.0 - s1;

		t1 = y - (float)j0;
		t0 = 1.0 - t1;
				
		ad_d[To1D(id)] = 
			s0 * (t0*ad_d0[To1D(i0,j0)] + t1*ad_d0[To1D(i0,j1)]) +
			s1 * (t0*ad_d0[To1D(i1,j0)] + t1*ad_d0[To1D(i1,j1)]);
	}
}



#pragma kernel Buffer2Texture

RWTexture2D<float4> b2t_texture;
RWStructuredBuffer<float> b2t_u;
RWStructuredBuffer<float> b2t_v;
RWStructuredBuffer<float> b2t_dens;

[numthreads(32, 32, 1)]
void Buffer2Texture(uint2 id : SV_DispatchThreadID) {
	float u = b2t_u[To1D(id)];
	float v = b2t_v[To1D(id)];
	float d = b2t_dens[To1D(id)];
	b2t_texture[id] = abs(float4(u, v, d, 1.0));
}
